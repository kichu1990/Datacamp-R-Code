# Load xts
library(xts)

# xts objects are simple. Think of them as a matrix of observations combined with an index of corresponding dates and times.
# xts = matrix + times
# The main xts constructor takes a number of arguments, but the two most important are x for the data and order.by for the index. 
# x must be a vector or matrix. order.by is a vector which must be the same length or number of rows as x, be a proper time or date 
# object (very important!), and be in increasing order.

# View the structure of ex_matrix
str(ex_matrix)

# Extract the 3rd observation of the 2nd column of ex_matrix
ex_matrix[3,2]

# Extract the 3rd observation of the 2nd column of core 
core[3,2]

# Create the object data using 5 random numbers
data <- rnorm(5)

# Create dates as a Date class object starting from 2016-01-01
dates <- seq(as.Date("2016-01-01"), length = 5, by = "days")

# Use xts() to create smith
smith <- xts(x = data, order.by = dates)

# Create bday (1899-05-08) using a POSIXct date class object
bday <- as.POSIXct("1899-05-08")

# Create hayek and add a new attribute called born
hayek <- xts(x = data, order.by = dates, born = bday)

# Extract the core data of hayek
hayek_core <- coredata(hayek)

# View the class of hayek_core
class(hayek_core)

# Extract the index of hayek
hayek_index <- index(hayek)

# View the class of hayek_index
class(hayek_index)

# Create dates
dates <- as.Date("2016-01-01") + 0:4

# Create ts_a
ts_a <- xts(x = 1:5, order.by = dates)

# Create ts_b
ts_b <- xts(x = 1:5, order.by = as.POSIXct(dates))

# Extract the rows of ts_a using the index of ts_b
ts_a[index(ts_b)]

# Extract the rows of ts_b using the index of ts_a
ts_b[index(ts_a)]

# Convert austres to an xts object called au
au <- as.xts(austres)

# Then convert your xts object (au) into a matrix am
am <- as.matrix(au)

# Inspect the head of am
head(am)

# Convert the original austres into a matrix am2
am2 <- as.matrix(austres)

# Inspect the head of am2
head(am2)

# Create dat by reading tmp_file
dat <- read.csv(tmp_file)

xts_dat <- xts(dat, order.by = as.POSIXct(rownames(dat)))

# Convert dat into xts
xts(dat, order.by = as.Date(rownames(dat), "%m/%d/%Y"))

# Read tmp_file using read.zoo
dat_zoo <- read.zoo(tmp_file, index.column = 0, sep = ",", format = "%m/%d/%Y")

# Convert dat_zoo to xts
dat_xts <- as.xts(dat_zoo)

# Convert sunspots to xts using as.xts().
sunspots_xts <- as.xts(sunspots)

# Get the temporary file name
tmp <- tempfile()

# Write the xts object using zoo to tmp 
write.zoo(sunspots_xts, sep = ",", file = tmp)

# Read the tmp file. FUN = as.yearmon converts strings such as Jan 1749 into a proper time class
sun <- read.zoo(tmp, sep = ",", FUN = as.yearmon)

# Convert sun into xts. Save this as sun_xts
sun_xts <- as.xts(sun)

# The ISO-8601 standard is the internationally recognized and accepted way to represent dates and times. The standard allows for a common
# format to not only describe dates, but also to represent ranges and repeating intervals.
# xts makes use of this standard for all extract and replace operations. This makes code both easy to write and easy to maintain. 
# It also makes for very concise expression of date ranges and intervals.

# One of the most powerful aspects of working with time series in xts is the ability to quickly and efficiently specify dates and time 
# ranges for subsetting.Date ranges can be extracted from xts objects by simply specifying the period(s) you want using special character
# strings in your subset.

# Select all of 2016 from x
x_2016 <- x["2016"]

# Select January 1, 2016 to March 22, 2016
jan_march <- x["2016/2016-03-22"]

# Verify that jan_march contains 82 rows
82 == length(jan_march)

# Extract all data between 8AM and 10AM
morn_2010 <- irreg["T08:00/T10:00"]

# Extract the observations for January 13th, 2010
morn_2010["2010-01-13"]

# Subset x using the vector dates
x[dates]

# Subset x using dates as POSIXct
x[as.POSIXct(dates)]

# Replace the values in x contained in the dates vector with NA
x[dates] <- NA

# Replace all values in x for dates starting June 9, 2016 with 0
x["2016-06-09/"] <- 0

# Verify that the value in x for June 11, 2016 is now indeed 0
x["2016-06-11"]

# Create lastweek using the last 1 week of temps
lastweek <- last(temps, "1 week")

# Print the last 2 observations in lastweek
last(lastweek, 2)

# Extract all but the first two days of lastweek
first(lastweek, "-2 days")

# Extract the first three days of the second week of temps
first(last(first(temps, "2 weeks"), "1 week"), "3 days")

# xts objects respect time. By design when you perform any binary operation using two xts objects, these objects are first aligned
# using the intersection of the indexes. This may be surprising when first encountered.
# The reason for this is that you want to preserve the point-in-time aspect of your data, assuring that you don't introduce accidental 
# look ahead (or look behind!) bias into your calculations.


# Add a and b
a + b

> a
           a
2015-01-24 1
2015-01-25 1
2015-01-26 1
> b
           b
2015-01-24 2

# Add a and b
a + b
> a + b
           a
2015-01-24 3

# Add a with the numeric value of b
a + as.numeric(b)

# Add a to b, and fill all missing rows of b with 0
a + merge(b, index(a), fill = 0)

# Add a to b and fill NAs with the last observation
a + merge(b, index(a), fill = na.locf)

# xts makes it easy to join data by column and row using a few different functions. All results will be correctly ordered in time, 
# regardless of original frequencies or date class. One of the most important functions to accomplish this is merge(). It takes one or 
# more series and joins them by column. It's also possible to combine a series with a vector of dates. This is especially useful for 
#normalizing observations to a fixed calendar.
# merge() takes three key arguments which we will emphasize here. First is the ..., which lets you pass in an arbitrary number of 
# objects to combine. The second argument is join, which specifies how to join the series - accepting arguments such as inner or left.
# This is similar to a relational database join, only here, the index is what we join on. The final argument for this exercise is fill.
# This keyword specifies what to do with the new values in a series if there is missingness introduced as a result of the merge.

>a
                    a
2016-06-05 -1.2070657
2016-06-08  0.2774292
2016-06-09  1.0844412
2016-06-13 -2.3456977

> b
                    b
2016-06-05  0.4291247
2016-06-06  0.5060559
2016-06-08 -0.5747400
2016-06-09 -0.5466319

# Perform an inner join of a and b
merge(a, b, join = "inner")

# Perform a left-join of a and b, fill missing values with 0
merge(a, b, join = "left", fill = 0)

# Row bind temps_june30 to temps, assign this to temps2
temps2 <- rbind(temps, temps_june30)

# Row bind temps_july17 and temps_july18 to temps2, call this temps3
temps3 <- rbind(temps2, temps_july17, temps_july18)

# Fill missing values in temps using the last observation
na.locf(temps)

# Fill missing values in temps using the next observation
na.locf(temps, fromLast = TRUE) 

# Create a leading object called lead_x
lead_x <- lag(x, k = -1)

# Create a lagging object called lag_x
lag_x  <- lag(x, k = 1)

# Merge your three series together and assign to z
z <- merge(lead_x, x, lag_x)

# Calculate the first difference of AirPass using lag and subtraction
diff_by_hand <- AirPass - lag(AirPass)

# Use merge to compare the first parts of diff_by_hand and diff(AirPass)
merge(head(diff_by_hand), head(diff(AirPass)))

# Calculate the first order 12 month difference of AirPass
diff(AirPass, lag = 12, differences = 1)
